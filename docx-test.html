<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Export Photos Portrait</title>
  <script src="https://cdn.jsdelivr.net/npm/blueimp-load-image/js/load-image.all.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/exceljs/dist/exceljs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver/dist/FileSaver.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docx/build/browser/docx.min.js"></script>
  <style>
    button { margin: 0.5em; padding: 0.75em 1.5em; font-size: 1em; }
    img { display: block; margin: 0.5em 0; max-width: 80vw; height: auto; }
  </style>
</head>
<body>
  <button id="btn1">Prendre photo 1</button>
  <img id="preview1" alt="Aucune photo 1">
  <button id="btn2">Prendre photo 2</button>
  <img id="preview2" alt="Aucune photo 2">
  <div>
    <button id="exportDocx" disabled>Exporter .docx</button>
    <button id="exportXlsx" disabled>Exporter .xlsx</button>
  </div>

  <script>
    // conversion cm → px (96 DPI)
    const cmToPx = cm => Math.round(cm / 2.54 * 96);
    const TARGET_W = cmToPx(5.25); // ≈198 px
    const TARGET_H = cmToPx(7);    // ≈265 px

    let images = []; // contiendra { buffer, previewURL }

    // charge + normalise + encode en WebP
    async function processFile(file, previewImgEl) {
      const dataURL = await new Promise(r => {
        const fr = new FileReader();
        fr.onload = () => r(fr.result);
        fr.readAsDataURL(file);
      });
      const { canvas } = await new Promise((resolve, reject) => {
        loadImage(
          dataURL,
          imgOrCanvas => resolve({ canvas: imgOrCanvas }),
          { orientation: true, canvas: true }
        );
      });
      return new Promise((resolve, reject) => {
        canvas.toBlob(blob => {
          const fr = new FileReader();
          fr.onload = () => {
            const buffer = fr.result;
            const previewURL = URL.createObjectURL(blob);
            previewImgEl.src = previewURL;
            resolve({ buffer, previewURL });
          };
          fr.onerror = reject;
          fr.readAsArrayBuffer(blob);
        }, 'image/webp', 0.8);
      });
    }

    function setupButton(btnId, previewId, idx) {
      document.getElementById(btnId).addEventListener('click', async () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.capture = 'environment';
        input.onchange = async () => {
          const file = input.files[0];
          images[idx] = await processFile(file, document.getElementById(previewId));
          // activer exports si on a deux images
          if (images[0] && images[1]) {
            exportDocxBtn.disabled = false;
            exportXlsxBtn.disabled = false;
          }
        };
        input.click();
      });
    }

    setupButton('btn1', 'preview1', 0);
    setupButton('btn2', 'preview2', 1);

    // --- Export DOCX ---
    const exportDocxBtn = document.getElementById('exportDocx');
    exportDocxBtn.addEventListener('click', async () => {
      const { Document, Packer, Paragraph, ImageRun, Table, TableRow, TableCell } = window.docx;
      const doc = new Document();
      const rows = images.map((img, i) => new TableRow({
        children: [
          new TableCell({
            children: [
              new Paragraph(`Photo ${i+1}`),
              new Paragraph({
                children: [new ImageRun({
                  data: img.buffer,
                  transformation: { width: TARGET_W, height: TARGET_H }
                })]
              })
            ]
          })
        ]
      }));
      const table = new Table({ rows });
      doc.addSection({ children: [table] });
      const blob = await Packer.toBlob(doc);
      saveAs(blob, 'photos.docx');
    });

    // --- Export XLSX ---
    const exportXlsxBtn = document.getElementById('exportXlsx');
    exportXlsxBtn.addEventListener('click', async () => {
      const wb = new ExcelJS.Workbook();
      const ws = wb.addWorksheet('Photos');
      // ajuster la taille de la colonne A pour TARGET_W
      ws.getColumn(1).width = TARGET_W * 0.14; // ExcelJS width approximé en caractères
      ws.getRow(1).height = TARGET_H * 0.75;   // ExcelJS row.height en points

      // insérer chaque image
      images.forEach((img, i) => {
        const id = wb.addImage({ buffer: img.buffer, extension: 'webp' });
        ws.addImage(id, {
          tl: { col: 0, row: i },
          ext: { width: TARGET_W, height: TARGET_H }
        });
      });

      const buf = await wb.xlsx.writeBuffer();
      saveAs(new Blob([buf]), 'photos.xlsx');
    });
  </script>
</body>
</html>
