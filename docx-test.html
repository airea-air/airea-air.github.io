<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Airea – Fiche de points de mesure</title>
  <style>
    :root {
      --airea-blue: #005fa1;
      --airea-light: #e6f2fa;
      --airea-border: #ccc;
      --border-radius: .5rem;
      --font-base: .9rem;
      --app-max-width: 480px;
      --box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      --green: #28a745;
      --error-red: #d9534f;
    }
    html, body {
      margin:0; padding:0;
      width:100%; height:100%;
      font-family:'Segoe UI',sans-serif;
      background:var(--airea-light);
      display:flex; align-items:center; justify-content:center;
    }
    .app {
      width:100%; max-width:var(--app-max-width);
      height:100%; display:flex; flex-direction:column;
      background:#fff; box-shadow:var(--box-shadow);
    }
    header {
      display:flex; justify-content:space-between; align-items:center;
      background:var(--airea-blue); color:#fff;
      padding:.4rem 1rem;
    }
    header h1 { margin:0; font-size:.95rem; font-weight:400; }
    header input {
      width:100px; text-align:center;
      border:none; border-radius:var(--border-radius);
      padding:.4rem; font-size:.85rem;
    }
    main {
      flex:1; padding:1rem; overflow-y:auto;
    }
    #errors {
      color:var(--error-red);
      margin-bottom:1rem;
    }
    #errors ul { padding-left:1.2rem; margin:0; }

    label {
      display:block; margin-bottom:.3rem;
      font-size:var(--font-base); font-weight:500; color:#333;
    }
    select, input[type=text], input[type=datetime-local],
    input[type=number], button {
      width:100%; padding:.6rem;
      border:1px solid var(--airea-border);
      border-radius:var(--border-radius);
      font-size:var(--font-base);
      box-shadow:var(--box-shadow);
      box-sizing:border-box;
    }
    .row { margin-bottom:1rem; }

    .coords {
      display:grid; grid-template-columns:1fr 1fr; gap:1rem;
      margin-bottom:1rem;
    }
    .photos {
      display:grid; grid-template-columns:repeat(2,1fr); gap:1rem;
      margin-bottom:1rem;
    }
    .photos button {
      position:relative; display:flex; align-items:center; justify-content:center;
      background:#fff; transition:.2s;
    }
    .photos button.filled {
      background:var(--airea-blue); color:#fff; border-color:var(--airea-blue);
    }

    .sensors {
      display:grid; grid-template-columns:repeat(3,1fr); gap:1rem;
      margin-bottom:1rem;
    }
    .sensors div { display:flex; flex-direction:column; }

    .footer {
      height:3.5rem; display:flex; align-items:center; justify-content:space-between;
      padding:0 .5rem; background:#f9f9f9; border-top:1px solid var(--airea-border);
    }
    .footer button {
      flex:1; margin:0 .25rem; border:none; cursor:pointer;
      border-radius:var(--border-radius);
      padding:.6rem; font-size:.95rem;
      box-shadow:var(--box-shadow);
    }
    #savePoint { background:var(--green); color:#fff; }
    #exportXlsx { background:var(--airea-blue); color:#fff; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Airea – Fiche de points de mesure</h1>
      <input id="affaire" value="AF25XX">
    </header>

    <main>
      <div id="errors"></div>
      <form id="pointForm" novalidate>
        <div class="row">
          <label for="pointSelect">Point de mesure</label>
          <select id="pointSelect">
            <option value="">-- Choisir --</option>
          </select>
        </div>
        <div class="row">
          <button type="button" id="btnGeo">Obtenir adresse & coordonnées</button>
        </div>
        <div class="row">
          <label for="address">Adresse</label>
          <input id="address" type="text" readonly>
        </div>
        <div class="coords">
          <div>
            <label for="latDMS">Latitude</label>
            <input id="latDMS" type="text" readonly>
          </div>
          <div>
            <label for="lngDMS">Longitude</label>
            <input id="lngDMS" type="text" readonly>
          </div>
        </div>
        <div class="photos">
          <button type="button" id="photo1Btn">Photo 1</button>
          <button type="button" id="photo2Btn">Photo 2</button>
        </div>
        <div class="sensors">
          <div><label for="no2">NO₂</label><input id="no2" type="number"></div>
          <div><label for="c6h6">C₆H₆</label><input id="c6h6" type="number"></div>
          <div><label for="pm10">PM₁₀</label><input id="pm10" type="number"></div>
        </div>
        <div class="row">
          <label for="datetime">Date & heure</label>
          <input id="datetime" type="datetime-local" required>
        </div>
      </form>
    </main>

    <footer class="footer">
      <button type="button" id="savePoint">Enregistrer</button>
      <button type="button" id="exportXlsx" disabled>Export en .xlsx</button>
    </footer>
  </div>

  <!-- Librairies externes -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-load-image/5.16.0/load-image.all.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/exceljs@4.3.0/dist/exceljs.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const get = id => document.getElementById(id);
    const pointSelect = get('pointSelect'),
          btnGeo      = get('btnGeo'),
          btnSave     = get('savePoint'),
          btnExport   = get('exportXlsx'),
          addressEl   = get('address'),
          latEl       = get('latDMS'),
          lngEl       = get('lngDMS'),
          no2El       = get('no2'),
          c6h6El      = get('c6h6'),
          pm10El      = get('pm10'),
          datetimeEl  = get('datetime'),
          photo1Btn   = get('photo1Btn'),
          photo2Btn   = get('photo2Btn'),
          errorsDiv   = get('errors'),
          affaireEl   = get('affaire');

    const points = {};
    let images = [null, null];

    // cm → px @96dpi
    const cmToPx = cm => Math.round(cm / 2.54 * 96);
    const TARGET_W = cmToPx(5.25),
          TARGET_H = cmToPx(7),
          TARGET_RATIO = TARGET_W / TARGET_H;

    // Remplir le select
    for (let i = 1; i <= 40; i++) {
      pointSelect.add(new Option(`P${i}`, `P${i}`));
    }
    pointSelect.addEventListener('change', () => {
      const pt = pointSelect.value;
      btnSave.textContent = pt ? `Enregistrer ${pt}` : 'Enregistrer';
    });

    // Date/heure par défaut
    function nowLocal() {
      const d = new Date(); d.setSeconds(0,0);
      const tz = d.getTimezoneOffset();
      return new Date(d.getTime() - tz*60000).toISOString().slice(0,16);
    }
    datetimeEl.value = nowLocal();

    // Affichage erreurs
    function showErrors(arr) {
      errorsDiv.innerHTML = `<ul>${arr.map(e=>`<li>${e}</li>`).join('')}</ul>`;
    }
    function clearErrors() {
      errorsDiv.innerHTML = '';
    }

    // toDMS
    const toDMS = v => {
      const deg = Math.floor(v),
            min = Math.floor((v - deg)*60),
            sec = Math.round((v - deg - min/60)*3600);
      return `${deg}°${min}'${sec}"`;
    };

    // Géoloc + adresse + DMS
    btnGeo.addEventListener('click', () => {
      clearErrors();
      if (!navigator.geolocation) {
        return showErrors(['Géolocalisation non supportée']);
      }
      navigator.geolocation.getCurrentPosition(async pos => {
        const { latitude, longitude } = pos.coords;
        const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}`);
        const d = await res.json(), a = d.address||{};
        addressEl.value = `${a.house_number||''} ${a.road||''}`.trim()
                        + ', ' + (a.city||a.town||a.village||a.county||'');
        latEl.value = toDMS(latitude);
        lngEl.value = toDMS(longitude);
      }, e => showErrors([`Erreur position : ${e.message}`]));
    });

    // Traitement des photos
    async function processFile(file) {
      const dataURL = await new Promise(resolve => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.readAsDataURL(file);
      });
      const { canvas: normCanvas } = await new Promise((resolve, reject) => {
        loadImage(dataURL, imgOrCanvas => resolve({ canvas: imgOrCanvas }), { orientation: true, canvas: true });
      });
      const w = normCanvas.width, h = normCanvas.height;
      let sx, sy, sw, sh;
      if (w / h > TARGET_RATIO) {
        sh = h; sw = h * TARGET_RATIO; sx = (w - sw) / 2; sy = 0;
      } else {
        sw = w; sh = w / TARGET_RATIO; sx = 0; sy = (h - sh) / 2;
      }
      const targetCanvas = document.createElement('canvas');
      targetCanvas.width = TARGET_W;
      targetCanvas.height = TARGET_H;
      const ctx = targetCanvas.getContext('2d');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(normCanvas, sx, sy, sw, sh, 0, 0, TARGET_W, TARGET_H);
      return await new Promise((resolve, reject) => {
        targetCanvas.toBlob(blob => {
          const fr = new FileReader();
          fr.onload = () => resolve(fr.result);
          fr.onerror = reject;
          fr.readAsArrayBuffer(blob);
        }, 'image/png');
      });
    }

    function setupButton(btnEl, idx) {
      btnEl.addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.capture = 'environment';
        input.onchange = async () => {
          images[idx] = await processFile(input.files[0]);
          btnEl.classList.add('filled');
          if (images[0] && images[1]) {
            btnExport.disabled = false;
          }
        };
        input.click();
      });
    }
    setupButton(photo1Btn, 0);
    setupButton(photo2Btn, 1);

    // Enregistrement local + validation
    btnSave.addEventListener('click', () => {
      clearErrors();
      const errs = [];
      const pt = pointSelect.value;
      if (!pt) errs.push('Sélectionner un point.');
      if (!datetimeEl.value) errs.push('Date & heure requises.');
      if (!no2El.value && !c6h6El.value && !pm10El.value) errs.push('Au moins une mesure de capteur.');
      if (!images[0] || !images[1]) errs.push('Les deux photos sont obligatoires.');
      if (errs.length) return showErrors(errs);

      points[pt] = {
        address: addressEl.value,
        lat: latEl.value,
        lng: lngEl.value,
        no2: no2El.value,
        c6h6: c6h6El.value,
        pm10: pm10El.value,
        datetime: datetimeEl.value,
        b64_1: images[0],
        b64_2: images[1]
      };

      // reset form
      addressEl.value = latEl.value = lngEl.value = '';
      no2El.value = c6h6El.value = pm10El.value = '';
      datetimeEl.value = nowLocal();
      photo1Btn.classList.remove('filled');
      photo2Btn.classList.remove('filled');
      images = [null, null];
      pointSelect.value = '';
      btnSave.textContent = 'Enregistrer';
      btnExport.disabled = true;
      clearErrors();
      alert(`Données ${pt} enregistrées !`);
    });

    // Export XLSX
    btnExport.addEventListener('click', async () => {
      console.log('Export XLSX déclenché');
      try {
        const wb = new ExcelJS.Workbook();
        const ws = wb.addWorksheet('Mesures');
        ws.columns = [
          { header:'Point', key:'point', width:10 },
          { header:'Adresse', key:'address', width:30 },
          { header:'Lat DMS', key:'lat', width:15 },
          { header:'Lng DMS', key:'lng', width:15 },
          { header:'Photo 1', key:'photo1', width:TARGET_W * 0.14 },
          { header:'Photo 2', key:'photo2', width:TARGET_W * 0.14 },
          { header:'NO₂', key:'no2', width:10 },
          { header:'C₆H₆', key:'c6h6', width:10 },
          { header:'PM₁₀', key:'pm10', width:10 },
          { header:'DateHeure', key:'datetime', width:20 }
        ];
        ws.getColumn('datetime').numFmt = 'dd/mm/yy hh:mm';
        let row = 2;
        for (const [pt,p] of Object.entries(points)) {
          ws.addRow({
            point:pt, address:p.address, lat:p.lat, lng:p.lng,
            photo1:'', photo2:'',
            no2:p.no2, c6h6:p.c6h6, pm10:p.pm10,
            datetime:new Date(p.datetime)
          });
          ws.getRow(row).height = Math.round(TARGET_H * 0.75);
          const id1 = wb.addImage({ buffer:p.b64_1, extension:'png' });
          ws.addImage(id1, { tl:{col:4,row:row-1}, ext:{width:TARGET_W,height:TARGET_H} });
          const id2 = wb.addImage({ buffer:p.b64_2, extension:'png' });
          ws.addImage(id2, { tl:{col:5,row:row-1}, ext:{width:TARGET_W,height:TARGET_H} });
          row++;
        }
        const buf = await wb.xlsx.writeBuffer();
        saveAs(new Blob([buf],{type:'application/octet-stream'}),
               `${affaireEl.value||'Sans_affaire'}_Fiche_de_points_de_mesure.xlsx`);
      } catch(err) {
        console.error('Erreur à l’export XLSX', err);
        showErrors(['Une erreur est survenue lors de l’export. Voir la console.']);
      }
    });
  });
  </script>
</body>
</html>
